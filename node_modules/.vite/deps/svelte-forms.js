import {
  isPromise
} from "./chunk-UCOEKEID.js";
import {
  derived,
  writable
} from "./chunk-DY7FSUYH.js";
import {
  get_store_value
} from "./chunk-K6MJRMI7.js";

// node_modules/svelte-forms/form.js
function form(...fields) {
  let names = [];
  let doubles = [];
  fields.forEach((field2) => {
    const obj = get_store_value(field2);
    if (names.includes(obj.name)) {
      doubles = doubles.includes(obj.name) ? doubles : [...doubles, obj.name];
    } else {
      names = [...names, obj.name];
    }
  });
  if (doubles.length) {
    throw new Error(`Cannot have the fields with the same name: ${doubles.join(", ")}`);
  }
  const store = derived(fields, (values) => {
    return {
      valid: values.every((value) => value.valid),
      dirty: values.some((value) => value.dirty),
      // Summary as a getter to avoid useless computation of data
      // if no one wants it
      get summary() {
        return values.reduce((carry, f) => {
          carry[f.name] = f.value;
          return carry;
        }, {});
      },
      errors: values.map((value) => {
        return value.errors.map((e) => {
          if (e.includes(".")) {
            return e;
          }
          return `${value.name}.${e}`;
        });
      }).flat().filter((value, index, self) => self.indexOf(value) === index),
      hasError(name) {
        return this.errors.findIndex((e) => e === name) !== -1;
      }
    };
  });
  const { subscribe } = store;
  function reset() {
    fields.forEach((field2) => field2.reset && field2.reset());
  }
  function clear() {
    fields.forEach((field2) => field2.clear && field2.clear());
  }
  async function validate() {
    for (const field2 of fields) {
      if (field2.validate)
        await field2.validate();
    }
  }
  function getField(name) {
    return fields.find((f) => get_store_value(f).name === name);
  }
  function summary() {
    return get_store_value(store).summary;
  }
  return { subscribe, reset, validate, getField, summary, clear };
}

// node_modules/svelte-forms/types.js
var defaultFieldOptions = {
  valid: true,
  checkOnInit: false,
  validateOnChange: true,
  stopAtFirstError: false
};
function isField(field2) {
  const keys = Object.keys(field2);
  return ["name", "value", "valid", "invalid", "errors"].every((key) => keys.includes(key));
}

// node_modules/svelte-forms/createFieldStore.js
function createFieldOject(name, value, errors = [], partialField = {}) {
  const field2 = {
    name,
    value,
    valid: true,
    invalid: false,
    errors: [],
    dirty: false
  };
  return processField(field2, errors, partialField);
}
function getValue(value) {
  const isStore = function(v) {
    return value.subscribe !== void 0;
  };
  const isField2 = function(v) {
    return !!value.name && value.valid !== void 0;
  };
  if (isStore(value)) {
    return get_store_value(value).value;
  } else if (isField2(value)) {
    return value.value;
  }
  return value;
}
async function getErrors(value, validators, stopAtFirstError = false) {
  const v = getValue(value);
  let errors = [];
  for (const validator of validators) {
    let result = validator(v);
    if (isPromise(result)) {
      result = await result;
    }
    if (stopAtFirstError && !result.valid) {
      errors = [result];
      break;
    }
    errors = [...errors, result];
  }
  return errors;
}
function processField(field2, validations, partialField = {}) {
  if (validations) {
    const errors = validations.filter((v) => !v.valid).map((v) => v.name);
    const valid = !errors.length;
    return { ...field2, valid, invalid: !valid, errors, ...partialField };
  }
  return field2;
}
function createFieldStore(name, v, validators = [], options) {
  const value = {
    name,
    value: v,
    valid: options.valid,
    invalid: !options.valid,
    dirty: false,
    errors: []
  };
  const store = writable(value);
  const { subscribe, update, set: _set } = store;
  async function set(field2, forceValidation = false) {
    if (!isField(field2)) {
      field2 = processField(get_store_value(store), [], { value: field2 });
    }
    if (forceValidation || options.validateOnChange) {
      let validations = await getErrors(field2, validators, options.stopAtFirstError);
      _set(processField(field2, validations, { dirty: true }));
    } else {
      _set(processField(field2, null, { dirty: true }));
    }
  }
  async function validate() {
    const errors = await getErrors(store, validators, options.stopAtFirstError);
    let obj;
    update((field2) => {
      obj = processField(field2, errors, { dirty: false });
      return obj;
    });
    return obj;
  }
  function reset() {
    _set(processField({
      dirty: false,
      errors: [],
      name,
      valid: options.valid,
      invalid: !options.valid,
      value: v
    }));
  }
  if (options.checkOnInit) {
    set(value);
  }
  function clear() {
    _set(processField({
      dirty: false,
      errors: [],
      name,
      valid: options.valid,
      invalid: !options.valid,
      value: null
    }));
  }
  return { subscribe, update, set, validate, reset, clear };
}

// node_modules/svelte-forms/field.js
function field(name, value, validators = [], options = {}) {
  return createFieldStore(name, value, validators, { ...defaultFieldOptions, ...options });
}

// node_modules/svelte-forms/use.style.js
function style(node, { field: field2 = null, valid = "valid", invalid = "invalid", dirty = "dirty" } = {}) {
  const unsubscribe = field2.subscribe((field3) => {
    if (field3.dirty) {
      node.classList.add(dirty);
      if (field3.valid) {
        node.classList.add(valid);
        node.classList.remove(invalid);
      } else {
        node.classList.add(invalid);
        node.classList.remove(valid);
      }
    } else {
      node.classList.remove(dirty);
    }
  });
  return {
    destroy: () => unsubscribe()
  };
}

// node_modules/svelte-forms/combined.js
function combined(name, fields, reducer, validators = [], options = defaultFieldOptions) {
  let resolve;
  const { subscribe } = derived(fields, (values, set) => {
    const value = reducer(values);
    const createValidations = () => {
      let errors = [];
      values.forEach((value2) => {
        errors = [
          ...errors,
          ...value2.errors.map((e) => {
            return { valid: false, name: `${value2.name}.${e}` };
          }).flat()
        ];
      });
      return errors;
    };
    const validations = createValidations();
    resolve = getErrors(value, validators, options.stopAtFirstError).then((combinedValidations) => {
      const obj = createFieldOject(name, value, [...combinedValidations, ...validations], {
        dirty: values.some((v) => v.dirty)
      });
      set(obj);
      return obj;
    });
    set(createFieldOject(name, value, validations, {
      dirty: values.some((v) => v.dirty)
    }));
  }, createFieldOject(name, reducer(fields.map((f) => get_store_value(f))), []));
  return {
    subscribe,
    validate: async () => {
      return resolve;
    }
  };
}
export {
  combined,
  defaultFieldOptions,
  field,
  form,
  style
};
//# sourceMappingURL=svelte-forms.js.map
