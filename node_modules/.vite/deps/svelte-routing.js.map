{
  "version": 3,
  "sources": ["../../svelte-routing/src/contexts.js", "../../svelte-routing/src/history.js", "../../svelte-routing/src/utils.js", "../../svelte-routing/src/Router.svelte", "../../svelte-routing/src/Route.svelte", "../../svelte-routing/src/Link.svelte", "../../svelte-routing/src/actions.js"],
  "sourcesContent": ["export const LOCATION = {};\nexport const ROUTER = {};\n", "/**\n * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/history.js\n *\n * https://github.com/reach/router/blob/master/LICENSE\n * */\n\nfunction getLocation(source) {\n  return {\n    ...source.location,\n    state: source.history.state,\n    key: (source.history.state && source.history.state.key) || \"initial\"\n  };\n}\n\nfunction createHistory(source, options) {\n  const listeners = [];\n  let location = getLocation(source);\n\n  return {\n    get location() {\n      return location;\n    },\n\n    listen(listener) {\n      listeners.push(listener);\n\n      const popstateListener = () => {\n        location = getLocation(source);\n        listener({ location, action: \"POP\" });\n      };\n\n      source.addEventListener(\"popstate\", popstateListener);\n\n      return () => {\n        source.removeEventListener(\"popstate\", popstateListener);\n\n        const index = listeners.indexOf(listener);\n        listeners.splice(index, 1);\n      };\n    },\n\n    navigate(to, { state, replace = false } = {}) {\n      state = { ...state, key: Date.now() + \"\" };\n      // try...catch iOS Safari limits to 100 pushState calls\n      try {\n        if (replace) {\n          source.history.replaceState(state, null, to);\n        } else {\n          source.history.pushState(state, null, to);\n        }\n      } catch (e) {\n        source.location[replace ? \"replace\" : \"assign\"](to);\n      }\n\n      location = getLocation(source);\n      listeners.forEach(listener => listener({ location, action: \"PUSH\" }));\n    }\n  };\n}\n\n// Stores history entries in memory for testing or other platforms like Native\nfunction createMemorySource(initialPathname = \"/\") {\n  let index = 0;\n  const stack = [{ pathname: initialPathname, search: \"\" }];\n  const states = [];\n\n  return {\n    get location() {\n      return stack[index];\n    },\n    addEventListener(name, fn) {},\n    removeEventListener(name, fn) {},\n    history: {\n      get entries() {\n        return stack;\n      },\n      get index() {\n        return index;\n      },\n      get state() {\n        return states[index];\n      },\n      pushState(state, _, uri) {\n        const [pathname, search = \"\"] = uri.split(\"?\");\n        index++;\n        stack.push({ pathname, search });\n        states.push(state);\n      },\n      replaceState(state, _, uri) {\n        const [pathname, search = \"\"] = uri.split(\"?\");\n        stack[index] = { pathname, search };\n        states[index] = state;\n      }\n    }\n  };\n}\n\n// Global history uses window.history as the source if available,\n// otherwise a memory history\nconst canUseDOM = Boolean(\n  typeof window !== \"undefined\" &&\n    window.document &&\n    window.document.createElement\n);\nconst globalHistory = createHistory(canUseDOM ? window : createMemorySource());\nconst { navigate } = globalHistory;\n\nexport { globalHistory, navigate, createHistory, createMemorySource };\n", "/**\n * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/utils.js\n *\n * https://github.com/reach/router/blob/master/LICENSE\n * */\n\nconst paramRe = /^:(.+)/;\n\nconst SEGMENT_POINTS = 4;\nconst STATIC_POINTS = 3;\nconst DYNAMIC_POINTS = 2;\nconst SPLAT_PENALTY = 1;\nconst ROOT_POINTS = 1;\n\n/**\n * Check if `string` starts with `search`\n * @param {string} string\n * @param {string} search\n * @return {boolean}\n */\nexport function startsWith(string, search) {\n  return string.substr(0, search.length) === search;\n}\n\n/**\n * Check if `segment` is a root segment\n * @param {string} segment\n * @return {boolean}\n */\nfunction isRootSegment(segment) {\n  return segment === \"\";\n}\n\n/**\n * Check if `segment` is a dynamic segment\n * @param {string} segment\n * @return {boolean}\n */\nfunction isDynamic(segment) {\n  return paramRe.test(segment);\n}\n\n/**\n * Check if `segment` is a splat\n * @param {string} segment\n * @return {boolean}\n */\nfunction isSplat(segment) {\n  return segment[0] === \"*\";\n}\n\n/**\n * Split up the URI into segments delimited by `/`\n * @param {string} uri\n * @return {string[]}\n */\nfunction segmentize(uri) {\n  return (\n    uri\n      // Strip starting/ending `/`\n      .replace(/(^\\/+|\\/+$)/g, \"\")\n      .split(\"/\")\n  );\n}\n\n/**\n * Strip `str` of potential start and end `/`\n * @param {string} str\n * @return {string}\n */\nfunction stripSlashes(str) {\n  return str.replace(/(^\\/+|\\/+$)/g, \"\");\n}\n\n/**\n * Score a route depending on how its individual segments look\n * @param {object} route\n * @param {number} index\n * @return {object}\n */\nfunction rankRoute(route, index) {\n  const score = route.default\n    ? 0\n    : segmentize(route.path).reduce((score, segment) => {\n        score += SEGMENT_POINTS;\n\n        if (isRootSegment(segment)) {\n          score += ROOT_POINTS;\n        } else if (isDynamic(segment)) {\n          score += DYNAMIC_POINTS;\n        } else if (isSplat(segment)) {\n          score -= SEGMENT_POINTS + SPLAT_PENALTY;\n        } else {\n          score += STATIC_POINTS;\n        }\n\n        return score;\n      }, 0);\n\n  return { route, score, index };\n}\n\n/**\n * Give a score to all routes and sort them on that\n * @param {object[]} routes\n * @return {object[]}\n */\nfunction rankRoutes(routes) {\n  return (\n    routes\n      .map(rankRoute)\n      // If two routes have the exact same score, we go by index instead\n      .sort((a, b) =>\n        a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index\n      )\n  );\n}\n\n/**\n * Ranks and picks the best route to match. Each segment gets the highest\n * amount of points, then the type of segment gets an additional amount of\n * points where\n *\n *  static > dynamic > splat > root\n *\n * This way we don't have to worry about the order of our routes, let the\n * computers do it.\n *\n * A route looks like this\n *\n *  { path, default, value }\n *\n * And a returned match looks like:\n *\n *  { route, params, uri }\n *\n * @param {object[]} routes\n * @param {string} uri\n * @return {?object}\n */\nfunction pick(routes, uri) {\n  let match;\n  let default_;\n\n  const [uriPathname] = uri.split(\"?\");\n  const uriSegments = segmentize(uriPathname);\n  const isRootUri = uriSegments[0] === \"\";\n  const ranked = rankRoutes(routes);\n\n  for (let i = 0, l = ranked.length; i < l; i++) {\n    const route = ranked[i].route;\n    let missed = false;\n\n    if (route.default) {\n      default_ = {\n        route,\n        params: {},\n        uri\n      };\n      continue;\n    }\n\n    const routeSegments = segmentize(route.path);\n    const params = {};\n    const max = Math.max(uriSegments.length, routeSegments.length);\n    let index = 0;\n\n    for (; index < max; index++) {\n      const routeSegment = routeSegments[index];\n      const uriSegment = uriSegments[index];\n\n      if (routeSegment !== undefined && isSplat(routeSegment)) {\n        // Hit a splat, just grab the rest, and return a match\n        // uri:   /files/documents/work\n        // route: /files/* or /files/*splatname\n        const splatName = routeSegment === \"*\" ? \"*\" : routeSegment.slice(1);\n\n        params[splatName] = uriSegments\n          .slice(index)\n          .map(decodeURIComponent)\n          .join(\"/\");\n        break;\n      }\n\n      if (uriSegment === undefined) {\n        // URI is shorter than the route, no match\n        // uri:   /users\n        // route: /users/:userId\n        missed = true;\n        break;\n      }\n\n      let dynamicMatch = paramRe.exec(routeSegment);\n\n      if (dynamicMatch && !isRootUri) {\n        const value = decodeURIComponent(uriSegment);\n        params[dynamicMatch[1]] = value;\n      } else if (routeSegment !== uriSegment) {\n        // Current segments don't match, not dynamic, not splat, so no match\n        // uri:   /users/123/settings\n        // route: /users/:id/profile\n        missed = true;\n        break;\n      }\n    }\n\n    if (!missed) {\n      match = {\n        route,\n        params,\n        uri: \"/\" + uriSegments.slice(0, index).join(\"/\")\n      };\n      break;\n    }\n  }\n\n  return match || default_ || null;\n}\n\n/**\n * Check if the `path` matches the `uri`.\n * @param {string} path\n * @param {string} uri\n * @return {?object}\n */\nfunction match(route, uri) {\n  return pick([route], uri);\n}\n\n/**\n * Add the query to the pathname if a query is given\n * @param {string} pathname\n * @param {string} [query]\n * @return {string}\n */\nfunction addQuery(pathname, query) {\n  return pathname + (query ? `?${query}` : \"\");\n}\n\n/**\n * Resolve URIs as though every path is a directory, no files. Relative URIs\n * in the browser can feel awkward because not only can you be \"in a directory\",\n * you can be \"at a file\", too. For example:\n *\n *  browserSpecResolve('foo', '/bar/') => /bar/foo\n *  browserSpecResolve('foo', '/bar') => /foo\n *\n * But on the command line of a file system, it's not as complicated. You can't\n * `cd` from a file, only directories. This way, links have to know less about\n * their current path. To go deeper you can do this:\n *\n *  <Link to=\"deeper\"/>\n *  // instead of\n *  <Link to=`{${props.uri}/deeper}`/>\n *\n * Just like `cd`, if you want to go deeper from the command line, you do this:\n *\n *  cd deeper\n *  # not\n *  cd $(pwd)/deeper\n *\n * By treating every path as a directory, linking to relative paths should\n * require less contextual information and (fingers crossed) be more intuitive.\n * @param {string} to\n * @param {string} base\n * @return {string}\n */\nfunction resolve(to, base) {\n  // /foo/bar, /baz/qux => /foo/bar\n  if (startsWith(to, \"/\")) {\n    return to;\n  }\n\n  const [toPathname, toQuery] = to.split(\"?\");\n  const [basePathname] = base.split(\"?\");\n  const toSegments = segmentize(toPathname);\n  const baseSegments = segmentize(basePathname);\n\n  // ?a=b, /users?b=c => /users?a=b\n  if (toSegments[0] === \"\") {\n    return addQuery(basePathname, toQuery);\n  }\n\n  // profile, /users/789 => /users/789/profile\n  if (!startsWith(toSegments[0], \".\")) {\n    const pathname = baseSegments.concat(toSegments).join(\"/\");\n\n    return addQuery((basePathname === \"/\" ? \"\" : \"/\") + pathname, toQuery);\n  }\n\n  // ./       , /users/123 => /users/123\n  // ../      , /users/123 => /users\n  // ../..    , /users/123 => /\n  // ../../one, /a/b/c/d   => /a/b/one\n  // .././one , /a/b/c/d   => /a/b/c/one\n  const allSegments = baseSegments.concat(toSegments);\n  const segments = [];\n\n  allSegments.forEach(segment => {\n    if (segment === \"..\") {\n      segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n\n  return addQuery(\"/\" + segments.join(\"/\"), toQuery);\n}\n\n/**\n * Combines the `basepath` and the `path` into one path.\n * @param {string} basepath\n * @param {string} path\n */\nfunction combinePaths(basepath, path) {\n  return `${stripSlashes(\n    path === \"/\" ? basepath : `${stripSlashes(basepath)}/${stripSlashes(path)}`\n  )}/`;\n}\n\n/**\n * Decides whether a given `event` should result in a navigation or not.\n * @param {object} event\n */\nfunction shouldNavigate(event) {\n  return (\n    !event.defaultPrevented &&\n    event.button === 0 &&\n    !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)\n  );\n}\n\nfunction hostMatches(anchor) {\n  const host = location.host\n  return (\n    anchor.host == host ||\n    // svelte seems to kill anchor.host value in ie11, so fall back to checking href\n    anchor.href.indexOf(`https://${host}`) === 0 ||\n    anchor.href.indexOf(`http://${host}`) === 0\n  )\n}\n\nexport { stripSlashes, pick, match, resolve, combinePaths, shouldNavigate, hostMatches };\n", null, null, null, "import { navigate } from \"./history.js\";\nimport { shouldNavigate, hostMatches } from \"./utils.js\";\n\n/**\n * A link action that can be added to <a href=\"\"> tags rather\n * than using the <Link> component.\n *\n * Example:\n * ```html\n * <a href=\"/post/{postId}\" use:link>{post.title}</a>\n * ```\n */\nfunction link(node) {\n  function onClick(event) {\n    const anchor = event.currentTarget;\n\n    if (\n      anchor.target === \"\" &&\n      hostMatches(anchor) &&\n      shouldNavigate(event)\n    ) {\n      event.preventDefault();\n      navigate(anchor.pathname + anchor.search, { replace: anchor.hasAttribute(\"replace\") });\n    }\n  }\n\n  node.addEventListener(\"click\", onClick);\n\n  return {\n    destroy() {\n      node.removeEventListener(\"click\", onClick);\n    }\n  };\n}\n\n/**\n * An action to be added at a root element of your application to\n * capture all relative links and push them onto the history stack.\n *\n * Example:\n * ```html\n * <div use:links>\n *   <Router>\n *     <Route path=\"/\" component={Home} />\n *     <Route path=\"/p/:projectId/:docId?\" component={ProjectScreen} />\n *     {#each projects as project}\n *       <a href=\"/p/{project.id}\">{project.title}</a>\n *     {/each}\n *   </Router>\n * </div>\n * ```\n */\nfunction links(node) {\n  function findClosest(tagName, el) {\n    while (el && el.tagName !== tagName) {\n      el = el.parentNode;\n    }\n    return el;\n  }\n\n  function onClick(event) {\n    const anchor = findClosest(\"A\", event.target);\n\n    if (\n      anchor &&\n      anchor.target === \"\" &&\n      hostMatches(anchor) &&\n      shouldNavigate(event) &&\n      !anchor.hasAttribute(\"noroute\")\n    ) {\n      event.preventDefault();\n      navigate(anchor.pathname + anchor.search, { replace: anchor.hasAttribute(\"replace\") });\n    }\n  }\n\n  node.addEventListener(\"click\", onClick);\n\n  return {\n    destroy() {\n      node.removeEventListener(\"click\", onClick);\n    }\n  };\n}\n\nexport { link, links };\n"],
  "mappings": "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",
  "names": ["location", "score", "match", "location", "base", "activeRoute", "basepath", "ctx", "location", "path", "component", "ctx", "location"]
}
